<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ZERO OS</title>
    <link rel="icon" href="data:," />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      html,
      body {
        height: 100%;
        width: 100%;
        overflow: hidden;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #0a0a12;
        color: #e0e0e0;
      }
      #root {
        height: 100%;
        width: 100%;
      }
      #loading {
        position: fixed;
        inset: 0;
        background: #0a0a12;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        transition: opacity 0.3s;
      }
      #loading.hidden {
        opacity: 0;
        pointer-events: none;
      }
      #loading h2 {
        color: #01f4cb;
        font-size: 24px;
        margin-bottom: 24px;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #2a2a3a;
        border-top-color: #01f4cb;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      #loading-status {
        color: #666;
        margin-top: 16px;
      }
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1a1a2e;
      }
      ::-webkit-scrollbar-thumb {
        background: #333;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <h2>Zero OS</h2>
      <div class="spinner"></div>
      <p id="loading-status">Loading...</p>
    </div>
    <div id="root"></div>

    <!-- Axiom IndexedDB Storage -->
    <script>
      window.AxiomStorage = {
        db: null,
        DB_NAME: 'zero-axiom',
        DB_VERSION: 2,
        STORE_NAME: 'commits',
        async init() {
          if (this.db) return true;
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
            request.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (db.objectStoreNames.contains('log')) db.deleteObjectStore('log');
              if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'seq' });
                store.createIndex('timestamp', 'timestamp', { unique: false });
              }
            };
            request.onsuccess = () => {
              this.db = request.result;
              resolve(true);
            };
            request.onerror = () => reject(request.error);
          });
        },
        async persistEntry(entry) {
          if (!this.db) await this.init();
          return new Promise((res, rej) => {
            const r = this.db
              .transaction(this.STORE_NAME, 'readwrite')
              .objectStore(this.STORE_NAME)
              .put(entry);
            r.onsuccess = () => res(entry.seq);
            r.onerror = () => rej(r.error);
          });
        },
        async persistEntries(entries) {
          if (!this.db) await this.init();
          if (!entries?.length) return 0;
          return new Promise((res, rej) => {
            const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
            const store = tx.objectStore(this.STORE_NAME);
            let c = 0;
            for (const e of entries) store.put(e).onsuccess = () => c++;
            tx.oncomplete = () => res(c);
            tx.onerror = () => rej(tx.error);
          });
        },
        async loadAll() {
          if (!this.db) await this.init();
          return new Promise((res, rej) => {
            const r = this.db
              .transaction(this.STORE_NAME, 'readonly')
              .objectStore(this.STORE_NAME)
              .getAll();
            r.onsuccess = () => res((r.result || []).sort((a, b) => a.seq - b.seq));
            r.onerror = () => rej(r.error);
          });
        },
        async getCount() {
          if (!this.db) await this.init();
          return new Promise((res, rej) => {
            const r = this.db
              .transaction(this.STORE_NAME, 'readonly')
              .objectStore(this.STORE_NAME)
              .count();
            r.onsuccess = () => res(r.result);
            r.onerror = () => rej(r.error);
          });
        },
        async clear() {
          if (!this.db) await this.init();
          return new Promise((res, rej) => {
            const r = this.db
              .transaction(this.STORE_NAME, 'readwrite')
              .objectStore(this.STORE_NAME)
              .clear();
            r.onsuccess = () => res();
            r.onerror = () => rej(r.error);
          });
        },
        async getLastSeq() {
          if (!this.db) await this.init();
          return new Promise((res, rej) => {
            const r = this.db
              .transaction(this.STORE_NAME, 'readonly')
              .objectStore(this.STORE_NAME)
              .openCursor(null, 'prev');
            r.onsuccess = () => res(r.result ? r.result.value.seq : -1);
            r.onerror = () => rej(r.error);
          });
        },
      };
    </script>

    <!-- ZosStorage - Unified IndexedDB Storage -->
    <script src="/zos-storage.js"></script>

    <script type="module" src="./desktop/main.tsx"></script>
  </body>
</html>
